#include <iostream>
#include <chrono>
#include <random>

#include "benchmark.h"
#include "navtoolbox.h"
#include "linalg.h"
#include "kalman_takasu.h"
#include "kalman_udu.h"
#include "kalman_takasu_eigen.h"
#include "kalman_udu_eigen.h"

using namespace Eigen;

/* Test the C-version of the Takasu Kalman filter on a simple problem */
static int kalman_test1(void)
{
    const float sigma = 1.5f;

    std::default_random_engine      generator(42);
    std::normal_distribution<float> distribution(0.0, sigma);

    const float pos[3*1] = { 1024.000f, 508.000f, 20.000f };

    // <kalman filter>
    float Ht[15*3] = {
        1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f
    };
    float P[15*15] = {
    19393.428f,    29.869f,   976.720f,  5891.911f,     9.143f,   298.992f,     0.000f,   120.803f,    -3.694f,    -1.611f,     1.077f,     0.406f,    -5.549f,    -9.884f,     4.193f,
       29.869f, 19425.288f,  -586.032f,     9.143f,  5901.664f,  -179.395f,  -120.803f,     0.000f,    -6.157f,    -0.930f,    -1.630f,     0.631f,    10.041f,    -6.469f,    -1.905f,
      976.720f,  -586.032f,   279.963f,   298.992f,  -179.395f,    40.925f,     3.694f,     6.157f,     0.000f,    -0.677f,    -0.323f,    -1.832f,    -0.590f,    -0.306f,     0.272f,
     5891.911f,     9.143f,   298.992f,  1801.487f,     2.799f,    91.527f,     0.000f,    36.980f,    -1.131f,    -0.326f,     0.218f,     0.082f,    -1.699f,    -3.026f,     1.284f,
        9.143f,  5901.664f,  -179.395f,     2.799f,  1804.473f,   -54.916f,   -36.980f,     0.000f,    -1.885f,    -0.188f,    -0.329f,     0.128f,     3.074f,    -1.980f,    -0.583f,
      298.992f,  -179.395f,    40.925f,    91.527f,   -54.916f,    10.384f,     1.131f,     1.885f,     0.000f,    -0.137f,    -0.065f,    -0.370f,    -0.181f,    -0.094f,     0.083f,
        0.000f,  -120.803f,     3.694f,     0.000f,   -36.980f,     1.131f,     0.762f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,    -0.062f,     0.041f,     0.016f,
      120.803f,     0.000f,     6.157f,    36.980f,     0.000f,     1.885f,     0.000f,     0.762f,    -0.000f,     0.000f,     0.000f,     0.000f,    -0.036f,    -0.063f,     0.024f,
       -3.694f,    -6.157f,     0.000f,    -1.131f,    -1.885f,     0.000f,     0.000f,    -0.000f,     0.762f,     0.000f,     0.000f,     0.000f,    -0.026f,    -0.012f,    -0.070f,
       -1.611f,    -0.930f,    -0.677f,    -0.326f,    -0.188f,    -0.137f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,
        1.077f,    -1.630f,    -0.323f,     0.218f,    -0.329f,    -0.065f,     0.000f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,     0.000f,
        0.406f,     0.631f,    -1.832f,     0.082f,     0.128f,    -0.370f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,
       -5.549f,    10.041f,    -0.590f,    -1.699f,     3.074f,    -0.181f,    -0.062f,    -0.036f,    -0.026f,     0.000f,     0.000f,     0.000f,     0.008f,     0.000f,     0.000f,
       -9.884f,    -6.469f,    -0.306f,    -3.026f,    -1.980f,    -0.094f,     0.041f,    -0.063f,    -0.012f,     0.000f,     0.000f,     0.000f,     0.000f,     0.008f,     0.000f,
        4.193f,    -1.905f,     0.272f,     1.284f,    -0.583f,     0.083f,     0.016f,     0.024f,    -0.070f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.008f
    };
    float R[3*3] = {
        2.902f,     1.395f,     0.900f,
        1.395f,     2.295f,     0.698f,
        0.900f,     0.698f,     2.362f
    };
    float x[15*1] = {
        1024.000f,  508.000f,  20.000f, 0.f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f
    };
    const float Phi[15*15] = {
        1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f };
    const float G[15*3] = {
        1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f };
    const float Q[3] = { 0.001000f,  0.001000f,  0.001000f };

    float dz[3];

    const int n = 15;
    const int m = 3;
    // </kalman filter>

    volatile float xr[3] = { 0, 0, 0 }; /* make sure the kalman filter results are not optimized away */

    int i;
    for (i = 0; i < 999999; i++)
    {
        dz[0] = distribution(generator) + pos[0];
        dz[1] = distribution(generator) + pos[1];
        dz[2] = distribution(generator) + pos[2];

        matmul("T", "N", m, 1, n, -1.0f, Ht, x, 1.0f, dz); // dz = z - H*x

        kalman_takasu(x, P, dz, R, Ht, n, m, 0.0f, NULL);
        kalman_predict(x, P, Phi, G, Q, n, 3);

        xr[0] = x[0];
        xr[1] = x[1];
        xr[2] = x[2];
    }
    printf("Takasu Final Position: %.4f %.4f %.4f\n", (double)xr[0], (double)xr[1], (double)xr[2]);
    return i;
}

// ----------------------------------------------------------------------------------

/* Test the C++ (Eigen) version of the Takasu Kalman filter on a simple problem */
static int kalman_test1_eigen(void)
{
    const float sigma = 1.5f;
    const float pos[3*1] = { 1024.000f,   508.000f,    20.000f };

    std::default_random_engine      generator(42);
    std::normal_distribution<float> distribution(0.0, sigma);

    // <kalman filter>
    float Ht_data[15*3] = {
        1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f
    };
    float P_data[15*15] = {
    19393.428f,    29.869f,   976.720f,  5891.911f,     9.143f,   298.992f,     0.000f,   120.803f,    -3.694f,    -1.611f,     1.077f,     0.406f,    -5.549f,    -9.884f,     4.193f,
       29.869f, 19425.288f,  -586.032f,     9.143f,  5901.664f,  -179.395f,  -120.803f,     0.000f,    -6.157f,    -0.930f,    -1.630f,     0.631f,    10.041f,    -6.469f,    -1.905f,
      976.720f,  -586.032f,   279.963f,   298.992f,  -179.395f,    40.925f,     3.694f,     6.157f,     0.000f,    -0.677f,    -0.323f,    -1.832f,    -0.590f,    -0.306f,     0.272f,
     5891.911f,     9.143f,   298.992f,  1801.487f,     2.799f,    91.527f,     0.000f,    36.980f,    -1.131f,    -0.326f,     0.218f,     0.082f,    -1.699f,    -3.026f,     1.284f,
        9.143f,  5901.664f,  -179.395f,     2.799f,  1804.473f,   -54.916f,   -36.980f,     0.000f,    -1.885f,    -0.188f,    -0.329f,     0.128f,     3.074f,    -1.980f,    -0.583f,
      298.992f,  -179.395f,    40.925f,    91.527f,   -54.916f,    10.384f,     1.131f,     1.885f,     0.000f,    -0.137f,    -0.065f,    -0.370f,    -0.181f,    -0.094f,     0.083f,
        0.000f,  -120.803f,     3.694f,     0.000f,   -36.980f,     1.131f,     0.762f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,    -0.062f,     0.041f,     0.016f,
      120.803f,     0.000f,     6.157f,    36.980f,     0.000f,     1.885f,     0.000f,     0.762f,    -0.000f,     0.000f,     0.000f,     0.000f,    -0.036f,    -0.063f,     0.024f,
       -3.694f,    -6.157f,     0.000f,    -1.131f,    -1.885f,     0.000f,     0.000f,    -0.000f,     0.762f,     0.000f,     0.000f,     0.000f,    -0.026f,    -0.012f,    -0.070f,
       -1.611f,    -0.930f,    -0.677f,    -0.326f,    -0.188f,    -0.137f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,
        1.077f,    -1.630f,    -0.323f,     0.218f,    -0.329f,    -0.065f,     0.000f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,     0.000f,
        0.406f,     0.631f,    -1.832f,     0.082f,     0.128f,    -0.370f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,
       -5.549f,    10.041f,    -0.590f,    -1.699f,     3.074f,    -0.181f,    -0.062f,    -0.036f,    -0.026f,     0.000f,     0.000f,     0.000f,     0.008f,     0.000f,     0.000f,
       -9.884f,    -6.469f,    -0.306f,    -3.026f,    -1.980f,    -0.094f,     0.041f,    -0.063f,    -0.012f,     0.000f,     0.000f,     0.000f,     0.000f,     0.008f,     0.000f,
        4.193f,    -1.905f,     0.272f,     1.284f,    -0.583f,     0.083f,     0.016f,     0.024f,    -0.070f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.008f
    };
    float R_data[3*3] = {
        2.902f,     1.395f,     0.900f,
        1.395f,     2.295f,     0.698f,
        0.900f,     0.698f,     2.362f
    };
    float x_data[15*1] = {
     1024.000f,  508.000f,  20.000f, 0.f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f
    };
    const float Phi_data[15*15] = {
        1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f };
    float G_data[15*3] = {
        1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f
    };
    float Q_data[3*3] = {
        0.001000f,  0.000000f,  0.000000f,
        0.000000f,  0.001000f,  0.000000f,
        0.000000f,  0.000000f,  0.001000f
    };

    const int StateDim = 15;
    const int MeasDim  = 3;

    // </kalman filter>
    // Convert the arrays to Eigen variables with dynamic sizes
    Matrix<float, MeasDim, MeasDim>   R  = Matrix<float, MeasDim, MeasDim>::Map(R_data);
    Matrix<float, StateDim, 1>        x  = Matrix<float, StateDim, 1>::Map(x_data);
    Matrix<float, StateDim, StateDim> P  = Matrix<float, StateDim, StateDim>::Map(P_data);
    Matrix<float, StateDim, MeasDim>  Ht = Matrix<float, StateDim, MeasDim>::Map(Ht_data);
    Matrix<float, MeasDim, StateDim>  H  = Ht.transpose();
    Matrix<float, StateDim, StateDim> Phi = Matrix<float, StateDim, StateDim>::Map(Phi_data);
    Matrix<float, StateDim, 3> G = Matrix<float, StateDim, 3>::Map(G_data);
    Matrix<float, 3, 3> Q = Matrix<float, 3, 3>::Map(Q_data);

    Matrix<float, MeasDim, 1> z;
    Matrix<float, MeasDim, 1> dz;

    volatile float xr[3] = { 0, 0, 0 }; /* volatile: make sure code is not optimized away */

    int i;
    for (i = 0; i < 999999; i++)
    {
        z(0) = distribution(generator) + pos[0];
        z(1) = distribution(generator) + pos[1];
        z(2) = distribution(generator) + pos[2];

        dz.noalias() = z - H * x;
        kalman_takasu_eigen<float, StateDim, MeasDim>(x, P, dz, R, H);
        kalman_predict_eigen<float, StateDim, 3>(x, P, Phi, G, Q);

        xr[0] = x(0);
        xr[1] = x(1);
        xr[2] = x(2);
    }
    printf("Eigen Kalman Position: %.4f %.4f %.4f\n", (double)xr[0], (double)xr[1], (double)xr[2]);
    return i;
}
// ----------------------------------------------------------------------------------

static int kalman_test1_udu_eigen(void)
{
    const float sigma = 1.5f;
    const float pos[3*1] = { 1024.000f,   508.000f,    20.000f };

    std::default_random_engine      generator(42);
    std::normal_distribution<float> distribution(0.0, sigma);

    // <kalman filter>
    float Ht_data[15*3] = {
        1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f
    };
    float P_data[15*15] = {
    19393.428f,    29.869f,   976.720f,  5891.911f,     9.143f,   298.992f,     0.000f,   120.803f,    -3.694f,    -1.611f,     1.077f,     0.406f,    -5.549f,    -9.884f,     4.193f,
       29.869f, 19425.288f,  -586.032f,     9.143f,  5901.664f,  -179.395f,  -120.803f,     0.000f,    -6.157f,    -0.930f,    -1.630f,     0.631f,    10.041f,    -6.469f,    -1.905f,
      976.720f,  -586.032f,   279.963f,   298.992f,  -179.395f,    40.925f,     3.694f,     6.157f,     0.000f,    -0.677f,    -0.323f,    -1.832f,    -0.590f,    -0.306f,     0.272f,
     5891.911f,     9.143f,   298.992f,  1801.487f,     2.799f,    91.527f,     0.000f,    36.980f,    -1.131f,    -0.326f,     0.218f,     0.082f,    -1.699f,    -3.026f,     1.284f,
        9.143f,  5901.664f,  -179.395f,     2.799f,  1804.473f,   -54.916f,   -36.980f,     0.000f,    -1.885f,    -0.188f,    -0.329f,     0.128f,     3.074f,    -1.980f,    -0.583f,
      298.992f,  -179.395f,    40.925f,    91.527f,   -54.916f,    10.384f,     1.131f,     1.885f,     0.000f,    -0.137f,    -0.065f,    -0.370f,    -0.181f,    -0.094f,     0.083f,
        0.000f,  -120.803f,     3.694f,     0.000f,   -36.980f,     1.131f,     0.762f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,    -0.062f,     0.041f,     0.016f,
      120.803f,     0.000f,     6.157f,    36.980f,     0.000f,     1.885f,     0.000f,     0.762f,    -0.000f,     0.000f,     0.000f,     0.000f,    -0.036f,    -0.063f,     0.024f,
       -3.694f,    -6.157f,     0.000f,    -1.131f,    -1.885f,     0.000f,     0.000f,    -0.000f,     0.762f,     0.000f,     0.000f,     0.000f,    -0.026f,    -0.012f,    -0.070f,
       -1.611f,    -0.930f,    -0.677f,    -0.326f,    -0.188f,    -0.137f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,
        1.077f,    -1.630f,    -0.323f,     0.218f,    -0.329f,    -0.065f,     0.000f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,     0.000f,
        0.406f,     0.631f,    -1.832f,     0.082f,     0.128f,    -0.370f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,
       -5.549f,    10.041f,    -0.590f,    -1.699f,     3.074f,    -0.181f,    -0.062f,    -0.036f,    -0.026f,     0.000f,     0.000f,     0.000f,     0.008f,     0.000f,     0.000f,
       -9.884f,    -6.469f,    -0.306f,    -3.026f,    -1.980f,    -0.094f,     0.041f,    -0.063f,    -0.012f,     0.000f,     0.000f,     0.000f,     0.000f,     0.008f,     0.000f,
        4.193f,    -1.905f,     0.272f,     1.284f,    -0.583f,     0.083f,     0.016f,     0.024f,    -0.070f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.008f
    };
    float R_data[3*3] = {
        2.902f,     1.395f,     0.900f,
        1.395f,     2.295f,     0.698f,
        0.900f,     0.698f,     2.362f
    };
    float x_data[15*1] = {
     1024.000f,  508.000f,  20.000f, 0.f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f
    };
    const float Phi_data[15*15] = {
        1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f,  0.000000f,
        0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  1.000000f };
    float G_data[15*3] = {
        1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,
        0.000000f,  0.000000f,  1.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f,  0.000000f
    };
    float Q_data[3*3] = {
        0.001000f,  0.000000f,  0.000000f,
        0.000000f,  0.001000f,  0.000000f,
        0.000000f,  0.000000f,  0.001000f
    };

    const int StateDim = 15;
    const int MeasDim  = 3;

    // </kalman filter>
    // Convert the arrays to Eigen variables with dynamic sizes
    Matrix<float, MeasDim, MeasDim>   R  = Matrix<float, MeasDim, MeasDim>::Map(R_data);
    Matrix<float, StateDim, 1>        x  = Matrix<float, StateDim, 1>::Map(x_data);
    Matrix<float, StateDim, StateDim> P  = Matrix<float, StateDim, StateDim>::Map(P_data);
    Matrix<float, StateDim, MeasDim>  Ht = Matrix<float, StateDim, MeasDim>::Map(Ht_data);
    Matrix<float, MeasDim, StateDim>  H  = Ht.transpose();
    Matrix<float, StateDim, StateDim> Phi = Matrix<float, StateDim, StateDim>::Map(Phi_data);
    Matrix<float, StateDim, 3> G = Matrix<float, StateDim, 3>::Map(G_data);
    Matrix<float, 3, 3> Q = Matrix<float, 3, 3>::Map(Q_data);
    Eigen::Matrix<float, StateDim, StateDim> U = Eigen::Matrix<float, StateDim, StateDim>::Identity();
    Eigen::Matrix<float, StateDim, 1>        d = P.diagonal();

    Eigen::Matrix<float, MeasDim, 1> z;

    volatile float xr[3] = {0, 0, 0};

    int i;
    for (i = 0; i < 999999; ++i)
    {
        z(0) = distribution(generator) + pos[0];
        z(1) = distribution(generator) + pos[1];
        z(2) = distribution(generator) + pos[2];

        // decorrelate measurements (in-place)
        Eigen::Matrix<float, MeasDim, MeasDim> Rdecor = R;
        Eigen::Matrix<float, MeasDim, StateDim> Hdecor = H;
        Eigen::Matrix<float, MeasDim, 1> zdecor = z;
        decorrelate_eigen<float, MeasDim, StateDim>(zdecor, Hdecor, Rdecor);

        // Update
        kalman_udu_eigen<float, StateDim, MeasDim>(x, U, d, zdecor, Rdecor, Hdecor);

        // Predict
        kalman_udu_predict_eigen<float, StateDim, 3>(x, U, d, Phi, G, Q_diag);

        xr[0] = x(0);
        xr[1] = x(1);
        xr[2] = x(2);
    }

    printf("UDU Eigen Kalman Position: %.4f %.4f %.4f\n", (double)xr[0], (double)xr[1], (double)xr[2]);
    return i;
}

/* Test the Bierman UDU filter */
static int kalman_test1_udu(void)
{
    const float sigma = 1.5f;

    std::default_random_engine      generator(42);
    std::normal_distribution<float> distribution(0.0, sigma);

    const float pos[3*1] = { 1024.000f,   508.000f,    20.000f };

    // <kalman filter>
    float Ht[15*3] = {
        1.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,    -0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,
        0.000f,     1.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,    -0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,
        0.000f,     0.000f,     1.000f,     0.000f,     0.000f,     0.000f,    -0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f
    };
    float P[15*15] = {
    19393.428f,    29.869f,   976.720f,  5891.911f,     9.143f,   298.992f,     0.000f,   120.803f,    -3.694f,    -1.611f,     1.077f,     0.406f,    -5.549f,    -9.884f,     4.193f,
       29.869f, 19425.288f,  -586.032f,     9.143f,  5901.664f,  -179.395f,  -120.803f,     0.000f,    -6.157f,    -0.930f,    -1.630f,     0.631f,    10.041f,    -6.469f,    -1.905f,
      976.720f,  -586.032f,   279.963f,   298.992f,  -179.395f,    40.925f,     3.694f,     6.157f,     0.000f,    -0.677f,    -0.323f,    -1.832f,    -0.590f,    -0.306f,     0.272f,
     5891.911f,     9.143f,   298.992f,  1801.487f,     2.799f,    91.527f,     0.000f,    36.980f,    -1.131f,    -0.326f,     0.218f,     0.082f,    -1.699f,    -3.026f,     1.284f,
        9.143f,  5901.664f,  -179.395f,     2.799f,  1804.473f,   -54.916f,   -36.980f,     0.000f,    -1.885f,    -0.188f,    -0.329f,     0.128f,     3.074f,    -1.980f,    -0.583f,
      298.992f,  -179.395f,    40.925f,    91.527f,   -54.916f,    10.384f,     1.131f,     1.885f,     0.000f,    -0.137f,    -0.065f,    -0.370f,    -0.181f,    -0.094f,     0.083f,
        0.000f,  -120.803f,     3.694f,     0.000f,   -36.980f,     1.131f,     0.762f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,    -0.062f,     0.041f,     0.016f,
      120.803f,     0.000f,     6.157f,    36.980f,     0.000f,     1.885f,     0.000f,     0.762f,    -0.000f,     0.000f,     0.000f,     0.000f,    -0.036f,    -0.063f,     0.024f,
       -3.694f,    -6.157f,     0.000f,    -1.131f,    -1.885f,     0.000f,     0.000f,    -0.000f,     0.762f,     0.000f,     0.000f,     0.000f,    -0.026f,    -0.012f,    -0.070f,
       -1.611f,    -0.930f,    -0.677f,    -0.326f,    -0.188f,    -0.137f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,
        1.077f,    -1.630f,    -0.323f,     0.218f,    -0.329f,    -0.065f,     0.000f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,     0.000f,
        0.406f,     0.631f,    -1.832f,     0.082f,     0.128f,    -0.370f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.040f,     0.000f,     0.000f,     0.000f,
       -5.549f,    10.041f,    -0.590f,    -1.699f,     3.074f,    -0.181f,    -0.062f,    -0.036f,    -0.026f,     0.000f,     0.000f,     0.000f,     0.008f,     0.000f,     0.000f,
       -9.884f,    -6.469f,    -0.306f,    -3.026f,    -1.980f,    -0.094f,     0.041f,    -0.063f,    -0.012f,     0.000f,     0.000f,     0.000f,     0.000f,     0.008f,     0.000f,
        4.193f,    -1.905f,     0.272f,     1.284f,    -0.583f,     0.083f,     0.016f,     0.024f,    -0.070f,     0.000f,     0.000f,     0.000f,     0.000f,     0.000f,     0.008f
    };
    float R[3*3] = {
        2.902f,     1.395f,     0.900f,
        1.395f,     2.295f,     0.698f,
        0.900f,     0.698f,     2.362f
    };
    float x[15*1] = {
        1024.000f,  508.000f,  20.000f, 0.f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f
    };
    const float Phi[15*15] = {
        1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f,  0.0f,
        0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  1.0f };
    const float G[15*3] = {
        1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,
        0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f,  0.0f };
    const float Q[3] = { 0.001000f,  0.001000f,  0.001000f };

    float z[3];

    const int n = 15;
    const int m = 3;
    // </kalman filter>

    volatile float xr[3] = { 0, 0, 0 }; /* make sure the kalman filter results are not optimized away */

    decorrelate(z, Ht, R, n, m);
    float U[15*15];
    float d[15];

    udu(P, U, d, n);

    float Reye[3*3];
    mateye(Reye, 3); // set R to eye(2)

    int i;
    for (i = 0; i < 999999; i++)
    {
        z[0] = distribution(generator) + pos[0];
        z[1] = distribution(generator) + pos[1];
        z[2] = distribution(generator) + pos[2];

        trisolve(R, z, m, 1, "N");

        kalman_udu(x, U, d, z, Reye, Ht, n, m, 0.0f, 0);

        kalman_udu_predict(x, U, d, Phi, G, Q, n, 3);

        xr[0] = x[0];
        xr[1] = x[1];
        xr[2] = x[2];
    }
    printf("UDU Final Position: %.4f %.4f %.4f\n", (double)xr[0], (double)xr[1], (double)xr[2]);
    return i;
}

// ----------------------------------------------------------------------------------

void benchmark1(void)
{
    {
        auto start = std::chrono::high_resolution_clock::now();

        int loops = kalman_test1();

        auto                          end      = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> duration = end - start;
        std::cout << "Duration Test: " << duration.count() << " s. "
                  << "sec/loop: " << (duration.count() / loops) << std::endl;
    }

    {
        auto start = std::chrono::high_resolution_clock::now();

        int loops = kalman_test1_eigen();

        auto                          end      = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> duration = end - start;
        std::cout << "Duration Eigen Test: " << duration.count() << " s. "
                  << "sec/loop: " << (duration.count() / loops) << std::endl;
    }

    {
        auto start = std::chrono::high_resolution_clock::now();

        int loops = kalman_test1_udu();

        auto                          end      = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> duration = end - start;
        std::cout << "Duration UDU Test: " << duration.count() << " s. "
                  << "sec/loop: " << (duration.count() / loops) << std::endl;
    }

    {
        auto start = std::chrono::high_resolution_clock::now();

        int loops = kalman_test1_udu_eigen();

        auto                          end      = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> duration = end - start;
        std::cout << "Duration UDU Test: " << duration.count() << " s. "
                  << "sec/loop: " << (duration.count() / loops) << std::endl;
    }
}

void benchmark(void)
{
    benchmark1();
}
